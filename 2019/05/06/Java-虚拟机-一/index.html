<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java," />










<meta name="description" content="1 运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些数据区域都有各自的用途，以及创建和销毁的时间。  1.1 程序计数器（线程私有）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 虚拟机(一)">
<meta property="og:url" content="http://super1peng.xyz/2019/05/06/Java-虚拟机-一/index.html">
<meta property="og:site_name" content="大大大大碗面">
<meta property="og:description" content="1 运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些数据区域都有各自的用途，以及创建和销毁的时间。  1.1 程序计数器（线程私有）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tNc79ly1g2rp24no6oj30db0ajgmr.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1g2rq2s4jetj30h008rgmq.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1g2rq3tmd69j30jb08gq5c.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1g2rq6jw1i0j30k008ngnu.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1g2rqi6o1fgj30fy03ht8s.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1g2rq7af9cxj30hv03d0uz.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1g2rq7tozqnj30ia03iwgt.jpg">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tNc79ly1g2rq8uykpjj30fk0dxjst.jpg">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tNc79ly1g2rq9fjnolj30cx08yq4e.jpg">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tNc79ly1g2rqa1detrj30ht0esta7.jpg ">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tNc79ly1g2rqap42pvj30hq0eqq4r.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1g2rqbb1b3gj30hl09kmyd.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1g2rqcl9nbdj30ci0cpagi.jpg">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tNc79ly1g2rqdf9gdfj30l804y0uq.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1g2rqdxwr0ej30kw03udhl.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1g2rqef8hu9j30g507b3zy.jpg">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tNc79ly1g2rqexmqc3j30lb05bwgw.jpg">
<meta property="og:updated_time" content="2019-05-06T09:47:18.855Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 虚拟机(一)">
<meta name="twitter:description" content="1 运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些数据区域都有各自的用途，以及创建和销毁的时间。  1.1 程序计数器（线程私有）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计">
<meta name="twitter:image" content="https://ws2.sinaimg.cn/large/006tNc79ly1g2rp24no6oj30db0ajgmr.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://super1peng.xyz/2019/05/06/Java-虚拟机-一/"/>





  <title>Java 虚拟机(一) | 大大大大碗面</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    

  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    
    <a href="https://github.com/super1peng"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大大大大碗面</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super1peng.xyz/2019/05/06/Java-虚拟机-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="super1peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/nice.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大大大大碗面">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java 虚拟机(一)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T17:46:51+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 阅读总量
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<h2 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1 运行时数据区域"></a>1 运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些数据区域都有各自的用途，以及创建和销毁的时间。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2rp24no6oj30db0ajgmr.jpg"></p>
<h3 id="1-1-程序计数器（线程私有）"><a href="#1-1-程序计数器（线程私有）" class="headerlink" title="1.1 程序计数器（线程私有）"></a>1.1 程序计数器（线程私有）</h3><p>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<h3 id="1-2-Java虚拟机栈（线程私有）"><a href="#1-2-Java虚拟机栈（线程私有）" class="headerlink" title="1.2 Java虚拟机栈（线程私有）"></a>1.2 Java虚拟机栈（线程私有）</h3><p>它的生命周期与线程相同，虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>虚拟机栈中局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>这个部分规定了两种异常：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</li>
<li>如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常；<h3 id="1-3-本地方法栈-（共享线程）"><a href="#1-3-本地方法栈-（共享线程）" class="headerlink" title="1.3 本地方法栈 （共享线程）"></a>1.3 本地方法栈 （共享线程）</h3></li>
</ul>
<p>虚拟机栈执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在Sun HotSpot虚拟机中直接把两部分合二为一。也会抛出：StackOverflowError和OutOfMemoryError异常。</p>
<h3 id="1-4-Java堆（共享线程）"><a href="#1-4-Java堆（共享线程）" class="headerlink" title="1.4 Java堆（共享线程）"></a>1.4 Java堆（共享线程）</h3><p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此也被叫做“GC堆”；</p>
<p>从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以分为新生代和老年代；在细致一点有Eden空间、From Survivor空间、To Survivor空间。<br>从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（TLAB）。<br>Java堆可以处于物理上不连续的内存空间，只要逻辑是连续的就可以。在实现时，既可以实现成固定大小的，也可以是可扩展的（-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配情况，并且堆也无法再扩展，将会抛出OutOfMemoryError异常。</p>
<h3 id="1-5-方法区（线程共享）"><a href="#1-5-方法区（线程共享）" class="headerlink" title="1.5 方法区（线程共享）"></a>1.5 方法区（线程共享）</h3><p>也是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h4 id="1-5-1-运行时常量池"><a href="#1-5-1-运行时常量池" class="headerlink" title="1.5.1 运行时常量池"></a>1.5.1 运行时常量池</h4><p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息之外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需求来实现这个内存区域。</p>
<p>同时运行时常量池具备动态特性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2rq2s4jetj30h008rgmq.jpg"></p>
<h3 id="1-6-直接内存"><a href="#1-6-直接内存" class="headerlink" title="1.6 直接内存"></a>1.6 直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。Java1.4中NIO类引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提升性能。</p>
<p>服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。</p>
<h2 id="2-HotSpot虚拟机对象探秘"><a href="#2-HotSpot虚拟机对象探秘" class="headerlink" title="2. HotSpot虚拟机对象探秘"></a>2. HotSpot虚拟机对象探秘</h2><h3 id="2-1-对象的创建"><a href="#2-1-对象的创建" class="headerlink" title="2.1 对象的创建"></a>2.1 对象的创建</h3><h4 id="2-1-1-步骤一：类加载检查"><a href="#2-1-1-步骤一：类加载检查" class="headerlink" title="2.1.1 步骤一：类加载检查"></a>2.1.1 步骤一：类加载检查</h4><p>虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量迟中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那么必须执行相应的类加载过程。</p>
<h4 id="2-1-2-步骤二：分配内存"><a href="#2-1-2-步骤二：分配内存" class="headerlink" title="2.1.2 步骤二：分配内存"></a>2.1.2 步骤二：分配内存</h4><p>在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。对象所需要的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中换分出来。假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲那边拨动一段与对象大小相等的距离，这种分配方式称之为“指针碰撞”（Bump the pointer）。如果Java堆中的内存不是规整的，已使用的内存和空间的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录下哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称之为“空闲列表”（Free List）。</p>
<p>选择哪种分配方式是由Java堆是否完整决定的，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法过程的收集器时，通常采用空闲列表。</p>
<p>对象创建时需要考虑的另外一个问题是：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的。可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。有两种解决方案：</p>
<p>一种是对分配内存空间的动作进行同步处理——实际上，虚拟机采用CAS配上失败重试的方式来保证更新操作的原子性；<br>一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存（Thread Local Allocation Buffer， TLAB）本地线程缓冲。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。</p>
<h4 id="2-1-3-步骤三：初始化为零值"><a href="#2-1-3-步骤三：初始化为零值" class="headerlink" title="2.1.3 步骤三：初始化为零值"></a>2.1.3 步骤三：初始化为零值</h4><p>内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="2-1-4-虚拟机对对象进行必要的设置"><a href="#2-1-4-虚拟机对对象进行必要的设置" class="headerlink" title="2.1.4 虚拟机对对象进行必要的设置"></a>2.1.4 虚拟机对对象进行必要的设置</h4><p>例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。根据虚拟机当前的运行状态的不同，对象头会有不同的设置方式。</p>
<h4 id="2-1-5-结束"><a href="#2-1-5-结束" class="headerlink" title="2.1.5 结束"></a>2.1.5 结束</h4><p>完成上述工作之后，从虚拟机的视角来看，一个新的对象已经产生，但是从Java程序的视角来说，对象创建才刚刚开始，<init>方法还没有执行，所有的字段还都是为零，所有一般来说在执行new指令之后会接着执行init方法，把对象按照程序员的意思来进行初始化。</init></p>
<h3 id="2-2-对象的内存布局"><a href="#2-2-对象的内存布局" class="headerlink" title="2.2 对象的内存布局"></a>2.2 对象的内存布局</h3><p>对象在内存中存储布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）</p>
<h4 id="2-2-1-对象头："><a href="#2-2-1-对象头：" class="headerlink" title="2.2.1 对象头："></a>2.2.1 对象头：</h4><p>用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别是32bit和64bit，被称之为“Mark Word”，它被设计成一个非固定的数据结构以编在极小的空间内存储尽量多的信息，它会根据对象的状态服用自己的存储空间。<br>对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br>另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。</p>
<h4 id="2-2-2-实例数据："><a href="#2-2-2-实例数据：" class="headerlink" title="2.2.2 实例数据："></a>2.2.2 实例数据：</h4><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops，从分配策略中可以看到，相同宽度的字段总是被分配到一起，在满足这个前提的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true，那么子类中较窄的变量可能会插入到父类变量的空隙中。</p>
<h4 id="2-2-3-对齐填充："><a href="#2-2-3-对齐填充：" class="headerlink" title="2.2.3 对齐填充："></a>2.2.3 对齐填充：</h4><p>仅仅起着占位符的作用，HotSpot VM的自动内存管理系统要求对象其实地址必须是8字节的整数倍，即对象的大小必须是8字节的整数倍。</p>
<h3 id="2-3-对象的访问定位"><a href="#2-3-对象的访问定位" class="headerlink" title="2.3 对象的访问定位"></a>2.3 对象的访问定位</h3><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的对象访问方式：句柄、直接指针</p>
<ul>
<li>如果使用句柄访问的话，那么Java堆中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2rq3tmd69j30jb08gq5c.jpg"></p>
<ul>
<li>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2rq6jw1i0j30k008ngnu.jpg"></p>
<h4 id="2-3-1-优缺点比较："><a href="#2-3-1-优缺点比较：" class="headerlink" title="2.3.1 优缺点比较："></a>2.3.1 优缺点比较：</h4><p>使用句柄最大的好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不会改变。使用直接指针访问方式的最大的好处就是速度快，它节省一次指针定位的时间开销，由于对象的访问在Java中非常频繁，所以节省的开销十分可观。Sun HotSpot使用的是第二种方式进行对象访问的。</p>
<h2 id="3-内存分配"><a href="#3-内存分配" class="headerlink" title="3 内存分配"></a>3 内存分配</h2><p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决两个问题：给对象分配内存以及回收分配给对象的内存。同时Java自动内存管理最核心的功能就是在堆内存汇总对象的分配与回收。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此也被称为GC堆（Garbage Collected Heap），从垃圾回收的角度，由于现在收集器基本都是采用分代垃圾收集算法，所以Java堆还可以细分成：新生代和老年代。再细致一点就是：Eden空间、From Survivor空间、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p>
<p>Java堆空间的基本结构：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2rqi6o1fgj30fy03ht8s.jpg"></p>
<p>上图所示的Eden区、S0区、S1区都属于新生代，tentired区属于老年代，大部分情况，对象都会首先在Eden区域分配，在一次新生代垃圾回收之后，如果对象还存活着，则会进入S0或者S1，并且对象的年龄还会加1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增大到一定程度之后（默认为15），就会被晋升到老年代中。对象晋升到老年代的年龄阈值可以通过参数：-XX:MaxTenuringThreshold来设置。</p>
<h3 id="3-1-对象首先在Eden区分配"><a href="#3-1-对象首先在Eden区分配" class="headerlink" title="3.1 对象首先在Eden区分配"></a>3.1 对象首先在Eden区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>大多数情况下，对象在新生代中Eden区进行分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p>
<p>新生代GC（Minor GC）：指发生新生代的垃圾收集动作，Minor GC非常频繁，回收速度一般也是比较快；<br>老年代GC（Major GC / Full GC）：指发生老年代的GC，出现了Major GC经常会伴随着至少一次的Minor GC（并非绝对的），Major GC的速度一般会比Minor GC慢10倍以上；</p>
<h3 id="3-2-大对象直接进入老年代"><a href="#3-2-大对象直接进入老年代" class="headerlink" title="3.2 大对象直接进入老年代"></a>3.2 大对象直接进入老年代</h3><p>大对象就是需要大量的连续内存空间的对象（比如：字符串，数组），直接进入老年代可以避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<h3 id="3-3-长期存活的对象将进入老年代"><a href="#3-3-长期存活的对象将进入老年代" class="headerlink" title="3.3 长期存活的对象将进入老年代"></a>3.3 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别到哪些对象应该放在新生代，哪些对象应该放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄计数器。</p>
<p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，将被移动到Survivor空间中，并将对象的年龄设为1。对象在Survivor中每熬过一次Minor GC，年龄就增加一岁，当它的年龄增加到一定程度之后（默认为15）就会被晋升到老年代，对象晋升到老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold来设置。</p>
<h3 id="3-4-动态对象年龄判定"><a href="#3-4-动态对象年龄判定" class="headerlink" title="3.4 动态对象年龄判定"></a>3.4 动态对象年龄判定</h3><p>为了更好的适应不同程序的内存情况，虚拟机不是永远要去对象年龄必须达到某值才能进入老年代，如果Survivor空间中相同的年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30900</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//allocation1 = new byte[30900 * 1024];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过添加参数运行：-XX:+PrintGCDetails</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2rq7af9cxj30hv03d0uz.jpg"></p>
<p>上图中我们可以看出，Eden区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用2000多k内存）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">900</span>*<span class="number">1024</span>];</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2rq7tozqnj30ia03iwgt.jpg"></p>
<blockquote>
<p>原因：因为给了allocation2分配内存的时候Eden区内存几乎已经被完全分配完了，当Eden区没有足够空间进行分配的时候，虚拟机将发起一次Minor GC，GC期间虚拟机又发现allocation1无法存入Survivor空间，所以只好通过分配担保机制把新生代的对象提前转移到老年代去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能存在Eden区，还是会在Eden区分配内存。</p>
</blockquote>
<h2 id="4-生存还是死亡？"><a href="#4-生存还是死亡？" class="headerlink" title="4. 生存还是死亡？"></a>4. 生存还是死亡？</h2><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收之前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g2rq8uykpjj30fk0dxjst.jpg"></p>
<h3 id="4-1-如何判断一个对象已经无效"><a href="#4-1-如何判断一个对象已经无效" class="headerlink" title="4.1 如何判断一个对象已经无效"></a>4.1 如何判断一个对象已经无效</h3><h4 id="4-1-1-引用计数算法"><a href="#4-1-1-引用计数算法" class="headerlink" title="4.1.1 引用计数算法"></a>4.1.1 引用计数算法</h4><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>客观地来说，引用计数算法的实现比较简单，判定效率也很高，大部分情况下是一个不错的算法，但是它很难解决对象之间相互循环引用的问题：下面的例子中，对象objA和objB都有字段instance，赋值令objA.instance = objB，objB.instance = objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> int_1MVB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">    ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC(); </span><br><span class="line">   objA.instance = objB;</span><br><span class="line">   objB.instance = objA;</span><br><span class="line">   objA = <span class="keyword">null</span>;</span><br><span class="line">   objB = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// 假设在这里发生了GC，objA和objB是否能被回收？</span></span><br><span class="line">   System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-1-2-可达性分析算法"><a href="#4-1-2-可达性分析算法" class="headerlink" title="4.1.2 可达性分析算法"></a>4.1.2 可达性分析算法</h4><p>基本思想是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2rq9fjnolj30cx08yq4e.jpg"></p>
<p>在Java语言中，可以作为GC Roots的对象包括以下几种：</p>
<ol>
<li>虚拟机栈中的引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中JNI（Native方法）引用的对象；<h3 id="4-2-再谈引用"><a href="#4-2-再谈引用" class="headerlink" title="4.2 再谈引用"></a>4.2 再谈引用</h3></li>
</ol>
<p>JDK1.2 之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种：</p>
<ul>
<li>强引用：指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的信用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象；</li>
<li>软引用：用来描述一些还有用但是并非必需的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li>
<li>弱引用：也描述非必需对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li>
<li>虚引用：也称为幽灵引用，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。<h3 id="4-3-并非“非死不可”"><a href="#4-3-并非“非死不可”" class="headerlink" title="4.3 并非“非死不可”"></a>4.3 并非“非死不可”</h3></li>
</ul>
<p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，要进行两次标记过程：如果对象在进行可达性分析之后发现没有与GC Roots相连接的引用链，那么它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过时，虚拟机将这两种情况都视为“没有必要执行”。如果被判定为有必要执行，那么对象将会放置在一个叫做“F-Queue”队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。如果在执行知引用还没有重新与引用链上的任何一个对象建立关联，那么则“死亡”。</p>
<h3 id="4-4-回收方法区"><a href="#4-4-回收方法区" class="headerlink" title="4.4 回收方法区"></a>4.4 回收方法区</h3><p>方法区（永久代）的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p>
<h4 id="4-4-1-回收废弃常量"><a href="#4-4-1-回收废弃常量" class="headerlink" title="4.4.1 回收废弃常量"></a>4.4.1 回收废弃常量</h4><p>回收废弃常量与回收Java堆中的对象十分类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”变量，也没有其他地方引用这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。</p>
<h4 id="4-4-2-回收无用的类"><a href="#4-4-2-回收无用的类" class="headerlink" title="4.4.2 回收无用的类"></a>4.4.2 回收无用的类</h4><p>判定一个类是否是“无用的类”：</p>
<ul>
<li>该类所有的实例都已经被回收；也就是Java堆中不存在该类的任何实例；</li>
<li>加载该类的ClassLoader已经被回收；</li>
<li>该类对应的java.lang.Class对象没有在任何地方引用，无法在任何地方通过反射访问该类的方法；<blockquote>
<p>注：虚拟机可以对无用的类进行回收，但是也不是一定。这和对象不同（对象不使用则一定要回收）！</p>
</blockquote>
</li>
</ul>
<h2 id="5-垃圾回收算法"><a href="#5-垃圾回收算法" class="headerlink" title="5 垃圾回收算法"></a>5 垃圾回收算法</h2><h3 id="5-1-标记-清除算法"><a href="#5-1-标记-清除算法" class="headerlink" title="5.1 标记-清除算法"></a>5.1 标记-清除算法</h3><p>最基础的算法，算法分为两个阶段“标记”和“清除”，首先标记出所有需要回收的对象，在标记完成之后统一回收所有被标记的对象，它的标记过程在之前也已经介绍过了。</p>
<p>它的不足主要有两点：</p>
<ul>
<li>一个是效率问题：标记和清除两个过程的效率都不高；</li>
<li>一个是空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2rqa1detrj30ht0esta7.jpg "></p>
<h3 id="5-2-复制算法"><a href="#5-2-复制算法" class="headerlink" title="5.2 复制算法"></a>5.2 复制算法</h3><p>为了解决效率问题，出现了复制算法，它将可用的内存按照容量划分为大小相同的两块，每次只使用其中的一块。当这一块的内存用完之后，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。这样就使每次内存回收都是对内存区间的一半进行回收。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2rqap42pvj30hq0eqq4r.jpg"></p>
<p>现在的商业虚拟机都是采用这种收集算法来回收新生代，IBM研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另一块Survivor空间上，最后再清理掉Eden和刚才用过的Survivor空间。Sun HotSpot虚拟机默认的Eden和Survivor的大小比例是8：1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%）。当Survivor空间不够时，需要依赖其他内存（这里指老年代）进行分配担保。</p>
<h3 id="5-3-标记-整理算法"><a href="#5-3-标记-整理算法" class="headerlink" title="5.3 标记-整理算法"></a>5.3 标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行回收，而是让所有存货的对象向一端进行移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2rqbb1b3gj30hl09kmyd.jpg"></p>
<h3 id="5-4-分代收集算法"><a href="#5-4-分代收集算法" class="headerlink" title="5.4 分代收集算法"></a>5.4 分代收集算法</h3><p>当前的商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般把Java堆划分成新生代和老年代，这样可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量的存活，那就选用复制算法。只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外的空间对它进行分配担保，就必须使用”标记-清理“或者”标记-整理“算法来进行回收。</p>
<h2 id="6-垃圾收集器"><a href="#6-垃圾收集器" class="headerlink" title="6 垃圾收集器"></a>6 垃圾收集器</h2><blockquote>
<p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器是内存回收的具体实现。</p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2rqcl9nbdj30ci0cpagi.jpg"></p>
<h3 id="6-1-Serial收集器（新生代使用复制算法，老年代使用标记-整理算法）"><a href="#6-1-Serial收集器（新生代使用复制算法，老年代使用标记-整理算法）" class="headerlink" title="6.1 Serial收集器（新生代使用复制算法，老年代使用标记-整理算法）"></a>6.1 Serial收集器（新生代使用复制算法，老年代使用标记-整理算法）</h3><p>Serial（串行）收集器是最基本的、历史最久远的垃圾收集器。它是一个单线程收集器，它的“单线程”不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（“Stop The World”），直到收集结束。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2rqdf9gdfj30l804y0uq.jpg"></p>
<p>它简单而高效（与其他收集器的单线程相比），Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模型下的虚拟机来说是个不错的选择。</p>
<h3 id="6-2-ParNew收集器（新生代使用复制算法，老年代使用标记-整理算法）"><a href="#6-2-ParNew收集器（新生代使用复制算法，老年代使用标记-整理算法）" class="headerlink" title="6.2 ParNew收集器（新生代使用复制算法，老年代使用标记-整理算法）"></a>6.2 ParNew收集器（新生代使用复制算法，老年代使用标记-整理算法）</h3><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为（Serial收集器的所有控制参数，收集算法，Stop The World，对象分配规则，回收策略）都与Serial收集器完全一样。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2rqdxwr0ej30kw03udhl.jpg"></p>
<p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器）配合工作。</p>
<p>并行和并发概念补充：</p>
<p>并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<br>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p>
<h3 id="6-3-Parallel-Scavenge收集器"><a href="#6-3-Parallel-Scavenge收集器" class="headerlink" title="6.3 Parallel Scavenge收集器"></a>6.3 Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一个新生代的收集器，它也是使用复制算法的收集器，又是并行的多线程的收集器……Parallel Scavenge收集器特点是它的关注点与其他收集器不同，CMS可能关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。（吞吐量=运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)）。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<h3 id="6-4-CMS收集器"><a href="#6-4-CMS收集器" class="headerlink" title="6.4 CMS收集器"></a>6.4 CMS收集器</h3><p>CMS收集器（Concurrent Mark Sweep）是一种以获取最短回收停顿时间为目标的收集器。运行步骤有四步：</p>
<ul>
<li>初始标记：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快；</li>
<li>并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象，但在这个阶段结束，这个闭包结构并不能保证包括当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方；</li>
<li>重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短；</li>
<li>并发清除：开启用户线程，同时GC线程开始对为标记的区域做清扫；</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2rqef8hu9j30g507b3zy.jpg"></p>
<p>主要优点：并发收集、低停顿</p>
<p>主要缺点：对CPU资源敏感、无法处理浮动垃圾、它使用“标记-清除”算法会导致收集结束时会有大量空间碎片产生；</p>
<h3 id="6-5-G1收集器"><a href="#6-5-G1收集器" class="headerlink" title="6.5 G1收集器"></a>6.5 G1收集器</h3><p>G1（Garbage First）是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高的概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。</p>
<p>具备以下几个特点：</p>
<ul>
<li>并发与并行：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The World的停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li>
<li>分代收集：虽然G1可以需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li>
<li>空间整合：与CMS的“标记-清理”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，从局部上来看是基于“复制”实现的。</li>
<li>可预测的停顿：这是G1相对于CMS来说的另一大优势，降低停顿时间是G1和CMS共同关注点，但是G1除了追求低停顿之外，还能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</li>
</ul>
<p>G1收集器的运作大致分为以下几个步骤：初始标记、并发标记、最终标记、筛选回放。</p>
<p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率。（把内存化整为零）</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2rqexmqc3j30lb05bwgw.jpg"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i>Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/15/TEM-阅读笔记/" rel="next" title="TEM 阅读笔记">
                <i class="fa fa-chevron-left"></i> TEM 阅读笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNzIwOC8xMzc0Mg=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/nice.jpg"
                alt="super1peng" />
            
              <p class="site-author-name" itemprop="name">super1peng</p>
              <p class="site-description motion-element" itemprop="description">享受生活</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/super1peng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:super1peng@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          
<div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=30 height=86 src="//music.163.com/outchain/player?type=2&id=28815250&auto=1&height=66"></iframe>
</div>
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-运行时数据区域"><span class="nav-number">1.</span> <span class="nav-text">1 运行时数据区域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-程序计数器（线程私有）"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 程序计数器（线程私有）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Java虚拟机栈（线程私有）"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 Java虚拟机栈（线程私有）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-本地方法栈-（共享线程）"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 本地方法栈 （共享线程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-Java堆（共享线程）"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 Java堆（共享线程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-方法区（线程共享）"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 方法区（线程共享）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-运行时常量池"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1 运行时常量池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-直接内存"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 直接内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-HotSpot虚拟机对象探秘"><span class="nav-number">2.</span> <span class="nav-text">2. HotSpot虚拟机对象探秘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-对象的创建"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 对象的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-步骤一：类加载检查"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 步骤一：类加载检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-步骤二：分配内存"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 步骤二：分配内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-步骤三：初始化为零值"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3 步骤三：初始化为零值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-虚拟机对对象进行必要的设置"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4 虚拟机对对象进行必要的设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-5-结束"><span class="nav-number">2.1.5.</span> <span class="nav-text">2.1.5 结束</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-对象的内存布局"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 对象的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-对象头："><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 对象头：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-实例数据："><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 实例数据：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-对齐填充："><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3 对齐填充：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-对象的访问定位"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 对象的访问定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-优缺点比较："><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 优缺点比较：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-内存分配"><span class="nav-number">3.</span> <span class="nav-text">3 内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-对象首先在Eden区分配"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 对象首先在Eden区分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-大对象直接进入老年代"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 大对象直接进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-长期存活的对象将进入老年代"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 长期存活的对象将进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-动态对象年龄判定"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 动态对象年龄判定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-生存还是死亡？"><span class="nav-number">4.</span> <span class="nav-text">4. 生存还是死亡？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-如何判断一个对象已经无效"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 如何判断一个对象已经无效</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-引用计数算法"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1 引用计数算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-可达性分析算法"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2 可达性分析算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-再谈引用"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 再谈引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-并非“非死不可”"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 并非“非死不可”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-回收方法区"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 回收方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-回收废弃常量"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.4.1 回收废弃常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-回收无用的类"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.4.2 回收无用的类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-垃圾回收算法"><span class="nav-number">5.</span> <span class="nav-text">5 垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-标记-清除算法"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-复制算法"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-标记-整理算法"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 标记-整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-分代收集算法"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-垃圾收集器"><span class="nav-number">6.</span> <span class="nav-text">6 垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-Serial收集器（新生代使用复制算法，老年代使用标记-整理算法）"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 Serial收集器（新生代使用复制算法，老年代使用标记-整理算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-ParNew收集器（新生代使用复制算法，老年代使用标记-整理算法）"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 ParNew收集器（新生代使用复制算法，老年代使用标记-整理算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-Parallel-Scavenge收集器"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 Parallel Scavenge收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-CMS收集器"><span class="nav-number">6.4.</span> <span class="nav-text">6.4 CMS收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-G1收集器"><span class="nav-number">6.5.</span> <span class="nav-text">6.5 G1收集器</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-child"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">super1peng</span>

  
</div>










<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  
  


  

  


  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
